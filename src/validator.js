// Generated by CoffeeScript 1.4.0
(function() {
  var Address, addressMatch, defaultMatchType, matchType, matchUnknownType, options, request, _;

  _ = require('underscore');

  request = require('request');

  options = {
    countryBias: "us",
    countryMatch: null
  };

  exports.setOptions = function(opts) {
    return _.extend(options, opts);
  };

  matchUnknownType = function(known, unknown) {
    var compare, find, found, foundProps, haveProps, otherAddress, prop, props, value, _i, _len,
      _this = this;
    compare = function(prop) {
      if (known[prop] && unknown[prop]) {
        if (known[prop].toLowerCase() === unknown[prop].toLowerCase()) {
          return true;
        }
        if (unknown.generated && unknown[prop + 'Abbr']) {
          return known[prop].toLowerCase() === unknown[prop + 'Abbr'].toLowerCase();
        } else if (known.generated && known[prop + 'Abbr']) {
          return known[prop + 'Abbr'].toLowerCase() === unknown[prop].toLowerCase();
        } else {
          return false;
        }
      }
      return !known[prop] && !unknown[prop];
    };
    if (known.isObject && unknown.isObject) {
      return compare('city') && compare('state') && compare('country');
    } else if (known.isObject && !unknown.isObject) {
      props = ['streetNumber', 'street', 'city', 'state', 'country', 'postalCode'];
      otherAddress = unknown.toString().toLowerCase();
      if (known.toString() === otherAddress) {
        return true;
      }
      foundProps = 0;
      haveProps = 0;
      find = function(val) {
        var oldlen;
        val = val.toLowerCase();
        oldlen = otherAddress.length;
        otherAddress = otherAddress.replace(new RegExp("\\b" + val + "\\b", "i"), "");
        if (oldlen !== otherAddress.length) {
          foundProps++;
          return true;
        }
        return false;
      };
      for (_i = 0, _len = props.length; _i < _len; _i++) {
        prop = props[_i];
        value = known[prop];
        if (value !== void 0) {
          found = find(value);
          if (!found && (prop === "state" || prop === "country" || prop === "street") && known[prop + "Abbr"] !== void 0) {
            found = find(known[prop + "Abbr"]);
          }
          if (!found && prop === "country" && value.toLowerCase() === "united states") {
            found = find("usa");
          }
          if (!found && prop === "street") {
            value = value.replace(/( street)/i, ' st');
            found = find(value);
            if (!found) {
              value = value.replace(/( road)/i, ' rd');
              find(value);
            }
          }
          if (!found && prop === "postalCode") {
            haveProps--;
          }
          haveProps++;
        }
      }
      otherAddress = otherAddress.replace(/[ ,]/g, '');
      return foundProps === haveProps && otherAddress.length === 0;
    } else {
      return known.toString().toLowerCase() === unknown.toString().toLowerCase();
    }
  };

  addressMatch = {
    streetAddress: [
      {
        location_type: "ROOFTOP",
        types: ["street_address"],
        exact: true
      }, {
        location_type: "RANGE_INTERPOLATED",
        types: ["street_address"],
        exact: false
      }
    ],
    route: [
      {
        location_type: "GEOMETRIC_CENTER",
        types: ["route"],
        exact: true
      }
    ],
    city: [
      {
        location_type: "APPROXIMATE",
        types: ["locality", "political"],
        exact: true
      }
    ],
    state: [
      {
        location_type: "APPROXIMATE",
        types: ["administrative_area_level_1", "political"],
        exact: true
      }
    ],
    country: [
      {
        location_type: "APPROXIMATE",
        types: ["country", "political"],
        exact: true
      }
    ],
    unknown: [
      {
        location_type: "unknown",
        types: ["unknown"],
        exact: true
      }
    ]
  };

  exports.match = matchType = {};

  _.each(addressMatch, function(list, name) {
    return matchType[name] = name;
  });

  /*
      Address object that provides useful methods. Create a new one by
        1. passing a map with these props: {street:'123 main st', city: 'boston', state: 'MA'|'massachussetts', country: 'US'|'United States'}
          None of the props are required, but chances are you wont have a valid address if you omit any of them (except for state)
        2. passing a string containing an address (the address class does not parse the string into parts)
        3. passing a result object from a google geocoding response. ie: geoResponse.results[0]
  
  
      The validator.validate callback will return to you these objects, except they will have all or some of the following properties:
          streetNumber: '100'
          street: 'North Main St'
          streetAbbr: 'N Main St'
          city: 'Boston'
          state: 'Massachussetts'
          stateAbbr: 'MA'
          country: 'United States'
          countryAbbr: 'US'
          postalCode: 02114
          location: {lat: 43.233332, lon: 23.2222243}
  
      Methods:
          toString(useCountryAbbr, useStateAbbr, useStreetAbbr) - returns a string representing the address. currently geared towards North American addresses
              useCountryAbbr = [optional] default: true - the resulting address string should use country abbr, not the full country name
              useStateAbbr   = [optional] default: true - the resulting address string should use state abbr, not the full state name
              useStreetAbbr  = [optional] default: false - the resulting address string should use street name abbr, not the full street name
              Note: the abbriviated values will only be used if they are available. The Address objects returned to you from the validate callback may have these available.
          equals(anotherAddress) - check if 2 addresses are probably* the same. IT DOES NOT CHECK STREET NAME/NUMBER
  */


  exports.Address = Address = (function() {

    Address.prototype.matchType = matchType.unknown;

    Address.prototype.exactMatch = null;

    function Address(address, isObject, generated) {
      var city, country, countryAbbr, getComponent, location, postalCode, state, stateAbbr, street, streetAbbr, streetNum, x, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      this.isObject = isObject != null ? isObject : false;
      this.generated = generated != null ? generated : false;
      if (_.isObject(address)) {
        this.isObject = true;
        if (address.address_components) {
          this.generated = true;
          location = {
            lat: (_ref = address.geometry) != null ? (_ref1 = _ref.location) != null ? _ref1.lat : void 0 : void 0,
            lon: (_ref2 = address.geometry) != null ? (_ref3 = _ref2.location) != null ? _ref3.lng : void 0 : void 0
          };
          this.exactMatch = !address.partial_match;
          _.each(addressMatch, function(list, name) {
            return _.each(list, function(obj) {
              if (obj.location_type === address.geometry.location_type && _.difference(obj.types, address.types).length === 0) {
                _this.matchType = name;
                if (!obj.exact) {
                  return _this.exactMatch = false;
                }
              }
            });
          });
          getComponent = this.componentFinder(address.address_components);
          _ref4 = getComponent('street_number', false), x = _ref4[0], streetNum = _ref4[1];
          _ref5 = getComponent('route', false), streetAbbr = _ref5[0], street = _ref5[1];
          _ref6 = getComponent('locality'), x = _ref6[0], city = _ref6[1];
          _ref7 = getComponent('administrative_area_level_1'), stateAbbr = _ref7[0], state = _ref7[1];
          _ref8 = getComponent('country'), countryAbbr = _ref8[0], country = _ref8[1];
          _ref9 = getComponent('postal_code', false), postalCode = _ref9[0], x = _ref9[1];
          address = {
            streetNumber: streetNum,
            street: street,
            streetAbbr: streetAbbr,
            city: city,
            state: state,
            stateAbbr: stateAbbr,
            country: country,
            countryAbbr: countryAbbr,
            postalCode: postalCode,
            location: location
          };
        }
        _.each(address, function(val, key) {
          return _this[key] = val;
        });
      } else {
        this.addressStr = address;
      }
    }

    Address.prototype.componentFinder = function(components) {
      return function(type, type2) {
        var it;
        if (type2 == null) {
          type2 = "political";
        }
        it = _.find(components, function(c) {
          return c.types[0] === type && (!type2 || c.types[1] === type2);
        });
        return [it != null ? it.short_name : void 0, it != null ? it.long_name : void 0];
      };
    };

    Address.prototype.toString = function(useCountryAbbr, useStateAbbr, useStreetAbbr) {
      var arr, countryVal, prop, stateVal, str, streetVal, _i, _len, _ref;
      if (useCountryAbbr == null) {
        useCountryAbbr = true;
      }
      if (useStateAbbr == null) {
        useStateAbbr = true;
      }
      if (useStreetAbbr == null) {
        useStreetAbbr = false;
      }
      if (!this.isObject) {
        return this.addressStr;
      }
      arr = [];
      stateVal = useStateAbbr && this.generated ? 'stateAbbr' : 'state';
      countryVal = useCountryAbbr && this.generated ? 'countryAbbr' : 'country';
      streetVal = useStreetAbbr && this.generated ? 'streetAbbr' : 'street';
      _ref = [streetVal, 'city', stateVal, countryVal];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        if (this[prop]) {
          arr.push(this[prop]);
        }
      }
      str = arr.join(', ');
      if (this.streetNumber) {
        str = "" + this.streetNumber + " " + str;
      }
      return str;
    };

    return Address;

  })();

  /*
      validate an input address.
  
      inputAddr: validator.Address object or map with 'street', 'city', 'state', 'country' keys, or string address
      cb: function(err, validAddresses, inexactMatches, geocodingResponse)
          err - something went wrong calling the google api
          validAddresses - list of Address objects. These are exact matches to your input, and will have proper spelling, caps etc. Its best that you use this instead of what you had
          inexactMatches - list of Address objects. Incomplete addresses or addresses that do not match your input address. useful for 'did you mean?' type UIs
          geocodingResponse - the json object that i got from google API
  */


  defaultMatchType = matchType.streetAddress;

  exports.validate = function(inputAddr, addressType, cb) {
    var inputAddress, opts, qs;
    if (addressType == null) {
      addressType = defaultMatchType;
    }
    if (arguments.length === 2) {
      cb = addressType;
      addressType = defaultMatchType;
    }
    inputAddress = inputAddr instanceof Address ? inputAddr : new Address(inputAddr);
    qs = {
      'sensor': false,
      'address': inputAddress.toString(),
      region: options.countryBias
    };
    if (options.countryMatch) {
      qs.components = "country:" + options.countryMatch;
    }
    opts = {
      json: true,
      url: "http://maps.googleapis.com/maps/api/geocode/json",
      method: 'GET',
      qs: qs
    };
    return request(opts, function(err, response, body) {
      var inexactMatches, validAddresses;
      if (err) {
        return cb(err, null, null);
      }
      if (body.results.length === 0) {
        return cb(null, [], [], body);
      }
      if (response.statusCode !== 200) {
        return cb(new Error('Google geocode API returned status code of #{response.statusCode}', [], [], body));
      }
      validAddresses = [];
      inexactMatches = [];
      _.each(body.results, function(result) {
        var address;
        address = new Address(result);
        if (addressType === matchType.unknown) {
          if (matchUnknownType(address, inputAddress)) {
            return validAddresses.push(address);
          } else {
            return inexactMatches.push(address);
          }
        } else if (addressType === address.matchType) {
          if (address.exactMatch) {
            return validAddresses.push(address);
          } else {
            return inexactMatches.push(address);
          }
        }
      });
      return cb(null, validAddresses, inexactMatches, body);
    });
  };

}).call(this);
